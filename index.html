<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Background</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Inter', 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            overflow: hidden;
            background: 
               radial-gradient(circle at 20% 30%, rgba(254, 118, 168, 0.6) 0%, transparent 50%),
                radial-gradient(circle at 80% 70%, rgba(215, 158, 179, 0.5) 0%, transparent 50%),
              radial-gradient(circle at 40% 80%, rgba(254, 118, 168, 0.4) 0%, transparent 40%),
                radial-gradient(circle at 60% 20%, rgba(215, 158, 179, 0.3) 0%, transparent 40%),
                linear-gradient(135deg, #fe76a8 0%, #d79eb3 100%);
            background-attachment: fixed;
        }

        #three-canvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
            opacity: 0.85;
            cursor: pointer;
        }
    </style>
</head>
<body>
    <canvas id="three-canvas"></canvas>

    <script type="module">
        import * as THREE from 'https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.module.min.js';

        const isMobile = window.innerWidth <= 768 || /Android|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);

        const curvePath = [10.136184463414924, -1.374508746897471, 10.384881573913269,
            9.1152593889854714, -1.374508746897471, 8.5846792797570011,
            9.0669355709754882, -1.0665123466336568, 5.8937771631608156,
            10.151040177840205, -0.65913653144937956, 3.4340491740541346,
            10.806779203170416, 1.8859391007298545, 0.46855774212986023,
            10.761433540147586, 2.8724172201359197, -1.2811838605587311,
            9.6195923104445065, 2.8724172201359197, -3.2833099941904766,
            6.9763020889151646, 2.7659257976905427, -4.7591958908830172,
            6.0461277891353697, 1.0727045302089879, -6.6638740164090482,
            7.3472235778544794, -1.8228856326635698, -9.0685043046185623,
            7.226367212900791, -1.8228856326635698, -10.499536640855691,
            5.8354566696263914, -1.8228856326635698, -12.039219379199908,
            3.6532357452141353, -0.20463983570573391, -13.87695442281038,
            -0.30169589630131455, 1.5965000671484342, -14.879986418947327,
            -2.8925694230502157, 2.2971364614427481, -13.892095587598131,
            -4.537672295357936, 4.5863515759659208, -12.140831652074551,
            -6.1287913464117594, 5.9653814634119815, -8.9776527318875896,
            -6.0120301606452813, 4.4081161943855998, -6.712084358394045,
            -5.2138252159038974, 2.820894808418279, -4.4532820412085607,
            -2.3424712835109611, 2.2032065005086259, -3.0788773693500198,
            -0.0076956453915433265, 1.8931797788880202, -1.6577070662471063,
            -0.24767503988481437, 2.8845808465856684, 0.073915859214221724,
            -2.2174044353598896, 4.2415524507318576, 2.215992718290742,
            -3.4526531678364756, 3.0615192023340851, 4.7922404932096558,
            -3.7356278971556445, 1.4054080369354316, 7.8432021841434629,
            -3.4003734463804118, 1.1924069108769393, 9.2464090886227073,
            -1.8851803760476225, 1.5269331003449989, 10.306083896408374,
            0.01071077144031829, 2.1101821577522295, 10.490880699847727,
            0.42562058195647001, 2.2759939598834387, 11.613129436580291,
            0.096405262182225115, 0.032317784084054391, 16.223455375061565,
            2.3458797884520433, 0.38907275257695584, 19.91188266079584,
            5.7018400098488771, 1.73337964747396, 20.615481586999959,
            7.9720939736751824, 1.73337964747396, 19.303399329816457,
            9.8672362721095652, 0.090083018057025177, 16.893338541618121,
            11.225959519544134, -1.374508746897471, 14.279002555560753,
            11.288646925965876, -1.374508746897471, 11.926359497447137,
            10.136184463414924, -1.374508746897471, 10.384881573913269
        ];

        const points = [];
        const len = curvePath.length;
        for (let p = 0; p < len; p += 3) {
            points.push(new THREE.Vector3(
                curvePath[p], 
                curvePath[p + 1], 
                curvePath[p + 2])
            );
        }
        const spline = new THREE.CatmullRomCurve3(points);

        const w = window.innerWidth;
        const h = window.innerHeight;
        const scene = new THREE.Scene();
        
        scene.fog = new THREE.FogExp2(0xfe76a8, isMobile ? 0.15 : 0.12);
        
        const bgGeometry = new THREE.SphereGeometry(50, isMobile ? 16 : 32, isMobile ? 16 : 32);
        const bgMaterial = new THREE.MeshBasicMaterial({
            color: 0xd79eb3,
            transparent: true,
            opacity: 0.2,
            side: THREE.BackSide
        });
        const bgSphere = new THREE.Mesh(bgGeometry, bgMaterial);
        scene.add(bgSphere);
        
        const camera = new THREE.PerspectiveCamera(75, w / h, 0.1, 1000);
        camera.position.z = 5;
        const renderer = new THREE.WebGLRenderer({ 
            canvas: document.getElementById('three-canvas'), 
            antialias: !isMobile,
            powerPreference: isMobile ? "low-power" : "high-performance"
        });
        renderer.setSize(w, h);
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        renderer.outputColorSpace = THREE.SRGBColorSpace;
        renderer.setClearColor(0xfe76a8, 0.1);
        
        if (isMobile) {
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        }

        const particleCount = isMobile ? 100 : 200;
        const particleGeometry = new THREE.BufferGeometry();
        const particlePositions = new Float32Array(particleCount * 3);
        const particleColors = new Float32Array(particleCount * 3);
        
        for (let i = 0; i < particleCount; i++) {
            particlePositions[i * 3] = (Math.random() - 0.5) * 100;
            particlePositions[i * 3 + 1] = (Math.random() - 0.5) * 100;
            particlePositions[i * 3 + 2] = (Math.random() - 0.5) * 100;
          
            if (Math.random() > 0.5) {
                // Pink particles
                particleColors[i * 3] = 0.95 + Math.random() * 0.05;
                particleColors[i * 3 + 1] = 0.5 + Math.random() * 0.2;
                particleColors[i * 3 + 2] = 0.65 + Math.random() * 0.15;
            } else {
                // White particles
                const intensity = 0.9 + Math.random() * 0.1;
                particleColors[i * 3] = intensity;
                particleColors[i * 3 + 1] = intensity;
                particleColors[i * 3 + 2] = intensity;
            }
        }
        
        particleGeometry.setAttribute('position', new THREE.BufferAttribute(particlePositions, 3));
        particleGeometry.setAttribute('color', new THREE.BufferAttribute(particleColors, 3));
        
        const particleMaterial = new THREE.PointsMaterial({
            size: isMobile ? 0.4 : 0.6,
            vertexColors: true,
            transparent: true,
            opacity: isMobile ? 0.5 : 0.7,
            blending: THREE.AdditiveBlending
        });
        
        const particles = new THREE.Points(particleGeometry, particleMaterial);
        scene.add(particles);
        
        const tubeGeo = new THREE.TubeGeometry(spline, isMobile ? 111 : 222, 0.65, isMobile ? 8 : 16, true);
        const edges = new THREE.EdgesGeometry(tubeGeo, 0.2);
        const lineMat = new THREE.LineBasicMaterial({ 
            color: 0xfe76a8,
            transparent: true,
            opacity: 0.9
        });
        const tubeLines = new THREE.LineSegments(edges, lineMat);
        scene.add(tubeLines);

        const innerTubeGeo = new THREE.TubeGeometry(spline, isMobile ? 111 : 222, 0.3, isMobile ? 6 : 8, true);
        const innerEdges = new THREE.EdgesGeometry(innerTubeGeo, 0.1);
        const innerLineMat = new THREE.LineBasicMaterial({ 
            color: 0xffffff,
            transparent: true,
            opacity: 0.8
        });
        const innerTubeLines = new THREE.LineSegments(innerEdges, innerLineMat);
        scene.add(innerTubeLines);

        const myImages = [
            {
                imagePath: 'piano 1.jpg',
                redirectUrl: 'piano.html'
            },
            {
                imagePath: 'writting.jpg',
                redirectUrl: 'birthday.html'
            },
            {
                imagePath: 'key1.jpg',
                redirectUrl: 'puzzle.html'
            },
            {
                imagePath: 'envelope1.jpg',
                redirectUrl: 'heart.html'
            },
            {
                imagePath: 'moon2.jpg',
                redirectUrl: 'phases.html'
            },
            {
                imagePath: 'pencil1.jpg',
                redirectUrl: 'tracing0.html'
            },
             {
                imagePath: 'cake1.jpg',
                redirectUrl: 'candle.html'
            },
            {
                imagePath: 'piano2.jpg',
                redirectUrl: 'piano.html'
            },
            {
                imagePath: 'key2.jpg',
                redirectUrl: 'puzzle.html'
            },
            {
                imagePath: 'envelope2.jpg',
                redirectUrl: 'heart.html'
            },
            {
                imagePath: 'moon1.jpg',
                redirectUrl: 'phases.html'
            },
            {
                imagePath: 'pencil2.jpg',
                redirectUrl: 'tracing0.html'
            },
             {
                imagePath: 'cake2.jpg',
                redirectUrl: 'candle.html'
            },
            {
                imagePath: 'writting.jpg',
                redirectUrl: 'birthday.html'
            },
            {
                imagePath: 'piano3.jpg',
                redirectUrl: 'piano.html'
            },
            {
                imagePath: 'key 3.jpg',
                redirectUrl: 'puzzle.html'
            },
            {
                imagePath: 'envelope3.jpg',
                redirectUrl: 'heart.html'
            },
            {
                imagePath: 'moon3.jpg',
                redirectUrl: 'phases.html'
            },
            {
                imagePath: 'writting.jpg',
                redirectUrl: 'birthday.html'
            },
            {
                imagePath: 'pencil3.jpg',
                redirectUrl: 'tracing0.html'
            },
             {
                imagePath: 'cake 3.jpg',
                redirectUrl: 'candle.html'
            },
             {
                imagePath: 'piano 1.jpg',
                redirectUrl: 'piano.html'
            },
            {
                imagePath: 'key1.jpg',
                redirectUrl: 'puzzle.html'
            },
            {
                imagePath: 'envelope1.jpg',
                redirectUrl: 'heart.html'
            },
            {
                imagePath: 'moon2.jpg',
                redirectUrl: 'phases.html'
            },
            {
                imagePath: 'writting.jpg',
                redirectUrl: 'birthday.html'
            },
            {
                imagePath: 'pencil1.jpg',
                redirectUrl: 'tracing0.html'
            },
             {
                imagePath: 'cake1.jpg',
                redirectUrl: 'candle.html'
            },
            {
                imagePath: 'piano2.jpg',
                redirectUrl: 'piano.html'
            },
            {
                imagePath: 'key2.jpg',
                redirectUrl: 'puzzle.html'
            },
            {
                imagePath: 'envelope2.jpg',
                redirectUrl: 'heart.html'
            },
            {
                imagePath: 'moon1.jpg',
                redirectUrl: 'phases.html'
            },
            {
                imagePath: 'pencil2.jpg',
                redirectUrl: 'tracing0.html'
            },
            {
                imagePath: 'writting.jpg',
                redirectUrl: 'birthday.html'
            },
             {
                imagePath: 'cake2.jpg',
                redirectUrl: 'candle.html'
            },
            {
                imagePath: 'piano3.jpg',
                redirectUrl: 'piano.html'
            },
            {
                imagePath: 'key 3.jpg',
                redirectUrl: 'puzzle.html'
            },
            {
                imagePath: 'envelope3.jpg',
                redirectUrl: 'heart.html'
            },
            {
                imagePath: 'moon3.jpg',
                redirectUrl: 'phases.html'
            },
            {
                imagePath: 'writting.jpg',
                redirectUrl: 'birthday.html'
            },
            {
                imagePath: 'pencil3.jpg',
                redirectUrl: 'tracing0.html'
            },
             {
                imagePath: 'cake 3.jpg',
                redirectUrl: 'candle.html'
            },
             {
                imagePath: 'piano 1.jpg',
                redirectUrl: 'piano.html'
            },
            {
                imagePath: 'writting.jpg',
                redirectUrl: 'birthday.html'
            },
            {
                imagePath: 'key1.jpg',
                redirectUrl: 'puzzle.html'
            },
            {
                imagePath: 'envelope1.jpg',
                redirectUrl: 'heart.html'
            },
            {
                imagePath: 'moon2.jpg',
                redirectUrl: 'phases.html'
            },
            {
                imagePath: 'pencil1.jpg',
                redirectUrl: 'tracing0.html'
            },
             {
                imagePath: 'cake1.jpg',
                redirectUrl: 'candle.html'
            },
            {
                imagePath: 'piano2.jpg',
                redirectUrl: 'piano.html'
            },
            {
                imagePath: 'key2.jpg',
                redirectUrl: 'puzzle.html'
            },
            {
                imagePath: 'writting.jpg',
                redirectUrl: 'birthday.html'
            },
            {
                imagePath: 'envelope2.jpg',
                redirectUrl: 'heart.html'
            },
            {
                imagePath: 'moon1.jpg',
                redirectUrl: 'phases.html'
            },
            {
                imagePath: 'pencil2.jpg',
                redirectUrl: 'tracing0.html'
            },
             {
                imagePath: 'cake2.jpg',
                redirectUrl: 'candle.html'
            },
            {
                imagePath: 'piano3.jpg',
                redirectUrl: 'piano.html'
            },
            {
                imagePath: 'key 3.jpg',
                redirectUrl: 'puzzle.html'
            },
            {
                imagePath: 'envelope3.jpg',
                redirectUrl: 'heart.html'
            },
            {
                imagePath: 'moon3.jpg',
                redirectUrl: 'phases.html'
            },
            {
                imagePath: 'pencil3.jpg',
                redirectUrl: 'tracing0.html'
            },
             {
                imagePath: 'cake 3.jpg',
                redirectUrl: 'candle.html'
            },
            {
                imagePath: 'writting.jpg',
                redirectUrl: 'birthday.html'
            }
        ];
        

        const textureLoader = new THREE.TextureLoader();
        const imageObjects = [];
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();

        myImages.forEach((imgData, index) => {
            const p = (index / myImages.length + Math.random() * 0.05) % 1;
            const pos = tubeGeo.parameters.path.getPointAt(p);
            pos.x += (Math.random() - 0.5) * 0.8;
            pos.z += (Math.random() - 0.5) * 0.8;
            
            const texture = textureLoader.load(imgData.imagePath);
            const imgSize = 0.15;
            
            const geometry = new THREE.BoxGeometry(imgSize, imgSize, imgSize);
            const materials = [
                new THREE.MeshBasicMaterial({ map: texture, transparent: true, opacity: 0.95 }),
                new THREE.MeshBasicMaterial({ map: texture, transparent: true, opacity: 0.95 }),
                new THREE.MeshBasicMaterial({ map: texture, transparent: true, opacity: 0.95 }),
                new THREE.MeshBasicMaterial({ map: texture, transparent: true, opacity: 0.95 }),
                new THREE.MeshBasicMaterial({ map: texture, transparent: true, opacity: 0.95 }),
                new THREE.MeshBasicMaterial({ map: texture, transparent: true, opacity: 0.95 })
            ];
            
            const imageCube = new THREE.Mesh(geometry, materials);
            imageCube.position.copy(pos);
            
            imageCube.rotation.set(
                Math.random() * Math.PI,
                Math.random() * Math.PI,
                Math.random() * Math.PI
            );
            
            const glowGeometry = new THREE.BoxGeometry(imgSize * 1.15, imgSize * 1.15, imgSize * 1.15);
            const glowMaterial = new THREE.MeshBasicMaterial({
                color: 0xfe76a8,
                transparent: true,
                opacity: 0.4,
                side: THREE.BackSide
            });
            const glow = new THREE.Mesh(glowGeometry, glowMaterial);
            imageCube.add(glow);
            
            imageCube.userData = { 
                redirectUrl: imgData.redirectUrl,
                clickable: true 
            };
            
            imageObjects.push({
                mesh: imageCube,
                rotationSpeed: {
                    x: (Math.random() - 0.5) * 0.02,
                    y: (Math.random() - 0.5) * 0.02,
                    z: (Math.random() - 0.5) * 0.02
                }
            });
            
            scene.add(imageCube);
        });

        const numBoxes = isMobile ? 20 : 40;
        const size = 0.075;
        const boxGeo = new THREE.BoxGeometry(size, size, size);
        for (let i = 0; i < numBoxes; i += 1) {
            const p = (i / numBoxes + Math.random() * 0.1) % 1;
            const pos = tubeGeo.parameters.path.getPointAt(p);
            pos.x += (Math.random() - 0.5) * 0.8;
            pos.z += (Math.random() - 0.5) * 0.8;
            const rote = new THREE.Vector3(
                Math.random() * Math.PI,
                Math.random() * Math.PI,
                Math.random() * Math.PI
            );
            const edges = new THREE.EdgesGeometry(boxGeo, 0.2);
            
            let color;
            if (Math.random() > 0.4) {
                // Pink boxes with variation
                const pinkHue = 0.92 + (Math.random() - 0.5) * 0.05;
                const pinkSat = 0.7 + Math.random() * 0.2;
                const pinkLight = 0.6 + Math.random() * 0.2;
                color = new THREE.Color().setHSL(pinkHue, pinkSat, pinkLight);
            } else {
                // White boxes
                const whiteIntensity = 0.85 + Math.random() * 0.15;
                color = new THREE.Color().setHSL(0, 0, whiteIntensity);
            }
            
            const lineMat = new THREE.LineBasicMaterial({ 
                color: color,
                transparent: true,
                opacity: 0.8
            });
            const boxLines = new THREE.LineSegments(edges, lineMat);
            boxLines.position.copy(pos);
            boxLines.rotation.set(rote.x, rote.y, rote.z);
            scene.add(boxLines);
        }

        document.getElementById('three-canvas').addEventListener('click', (event) => {
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
            
            raycaster.setFromCamera(mouse, camera);
            
            const clickableObjects = imageObjects.map(obj => obj.mesh);
            const intersects = raycaster.intersectObjects(clickableObjects);
            
            if (intersects.length > 0) {
                const clickedObject = intersects[0].object;
                if (clickedObject.userData.clickable && clickedObject.userData.redirectUrl) {
                    window.open(clickedObject.userData.redirectUrl, '_blank');
                }
            }
        });

        function updateCamera(t) {
            const time = t * (isMobile ? 0.04 : 0.1);
            const looptime = 10 * 1000;
            const p = (time % looptime) / looptime;
            const pos = tubeGeo.parameters.path.getPointAt(p);
            const lookAt = tubeGeo.parameters.path.getPointAt((p + 0.03) % 1);
            camera.position.copy(pos);
            camera.lookAt(lookAt);
        }

        function animate(t = 0) {
            requestAnimationFrame(animate);
            
            particles.rotation.x += isMobile ? 0.0003 : 0.0005;
            particles.rotation.y += isMobile ? 0.0006 : 0.001;
            
            imageObjects.forEach(obj => {
                obj.mesh.rotation.x += obj.rotationSpeed.x;
                obj.mesh.rotation.y += obj.rotationSpeed.y;
                obj.mesh.rotation.z += obj.rotationSpeed.z;
            });
            
            updateCamera(t);
            renderer.render(scene, camera);
        }
        animate();

        function handleWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
        window.addEventListener('resize', handleWindowResize, false);
    </script>
</body>
</html>